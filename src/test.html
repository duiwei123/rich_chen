<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿å†™å­—ç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }
        
        #video {
            position: absolute;
            top: 0;
            left: 0;
            transform: scaleX(-1);
            opacity: 0.3;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            transform: scaleX(-1);
            cursor: crosshair;
        }
        
        #ui-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            display: none;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }
        
        .tool-section {
            margin: 20px 0;
            text-align: center;
        }
        
        .tool-button {
            width: 80px;
            height: 80px;
            margin: 10px;
            border: 3px solid #333;
            border-radius: 15px;
            cursor: pointer;
            display: inline-block;
            position: relative;
            transition: all 0.3s;
        }
        
        .tool-button:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .tool-button.selected {
            border-color: #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        
        .pen-icon {
            background: linear-gradient(45deg, #2196F3, #64B5F6);
            position: relative;
        }
        
        .pen-icon::after {
            content: 'âœï¸';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
        }
        
        .eraser-icon {
            background: linear-gradient(45deg, #FF9800, #FFB74D);
            position: relative;
        }
        
        .eraser-icon::after {
            content: 'ğŸ§¹';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 30px;
        }
        
        .color-palette {
            display: flex;
            justify-content: center;
            margin: 10px 0;
        }
        
        .color-option {
            width: 40px;
            height: 40px;
            margin: 5px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .color-option:hover {
            transform: scale(1.2);
        }
        
        .color-option.selected {
            border-color: #333;
            transform: scale(1.2);
        }
        
        .size-slider {
            width: 200px;
            margin: 10px auto;
        }
        
        .snowflake {
            position: absolute;
            color: white;
            font-size: 20px;
            pointer-events: none;
            animation: fall linear forwards;
        }
        
        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }
        
        .cursor-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid #4CAF50;
            border-radius: 50%;
            pointer-events: none;
            z-index: 999;
        }
    </style>
</head>
<body>
    <video id="video" width="1280" height="720" autoplay></video>
    <canvas id="canvas" width="1280" height="720"></canvas>
    
    <div id="ui-panel">
        <h2 style="text-align: center; margin-bottom: 30px;">é€‰æ‹©å·¥å…·</h2>
        
        <div class="tool-section">
            <div class="tool-button pen-icon" data-tool="pen"></div>
            <div class="tool-button eraser-icon" data-tool="eraser"></div>
        </div>
        
        <div class="tool-section">
            <h3>é¢œè‰²</h3>
            <div class="color-palette">
                <div class="color-option selected" style="background: #FFFFFF" data-color="#FFFFFF"></div>
                <div class="color-option" style="background: #FF0000" data-color="#FF0000"></div>
                <div class="color-option" style="background: #00FF00" data-color="#00FF00"></div>
                <div class="color-option" style="background: #0000FF" data-color="#0000FF"></div>
                <div class="color-option" style="background: #FFFF00" data-color="#FFFF00"></div>
                <div class="color-option" style="background: #FF00FF" data-color="#FF00FF"></div>
            </div>
        </div>
        
        <div class="tool-section">
            <h3>å¤§å°</h3>
            <input type="range" class="size-slider" min="2" max="50" value="5" id="size-slider">
            <div id="size-display" style="text-align: center; margin-top: 10px;">5px</div>
        </div>
    </div>
    
    <div class="cursor-indicator" id="cursor-indicator"></div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const uiPanel = document.getElementById('ui-panel');
        const cursorIndicator = document.getElementById('cursor-indicator');
        
        let hands = null;
        let isDrawing = false;
        let isUIPanelOpen = false;
        let currentTool = 'pen';
        let currentColor = '#FFFFFF';
        let currentSize = 5;
        let lastPoint = null;
        let drawings = [];
        let scale = 1;
        let rotation = 0;
        
        // åˆå§‹åŒ–æ‘„åƒå¤´
        async function initCamera() {
            const stream = await navigator.mediaDevices.getUserMedia({ 
                video: { width: 1280, height: 720 } 
            });
            video.srcObject = stream;
            return new Promise(resolve => {
                video.onloadedmetadata = resolve;
            });
        }
        
        // åˆå§‹åŒ–MediaPipe
        function initMediaPipe() {
            hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults(onResults);
        }
        
        // å¤„ç†æ‰‹åŠ¿ç»“æœ
        function onResults(results) {
            if (!results.multiHandLandmarks) return;
            
            const handsCount = results.multiHandLandmarks.length;
            
            // æ£€æµ‹æ‰‹æŒï¼ˆå¼ å¼€æ‰‹ï¼‰
            if (handsCount >= 1) {
                const hand = results.multiHandLandmarks[0];
                if (isPalmOpen(hand)) {
                    if (!isUIPanelOpen) {
                        isUIPanelOpen = true;
                        uiPanel.style.display = 'block';
                    }
                }
            }
            
            // UIé¢æ¿æ¨¡å¼
            if (isUIPanelOpen && handsCount >= 1) {
                const hand = results.multiHandLandmarks[0];
                const indexFinger = hand[8];
                
                // ä½¿ç”¨é£ŸæŒ‡é€‰æ‹©UIå…ƒç´ 
                const x = indexFinger.x * canvas.width;
                const y = indexFinger.y * canvas.height;
                
                updateCursor(x, y);
                handleUISelection(x, y);
                
            } else if (!isUIPanelOpen) {
                // å†™å­—æ¨¡å¼
                if (handsCount === 1) {
                    const hand = results.multiHandLandmarks[0];
                    handleDrawing(hand);
                } else if (handsCount === 2) {
                    // åŒæ‰‹æ‰‹åŠ¿
                    handleTwoHands(results.multiHandLandmarks);
                }
            }
        }
        
        // æ£€æµ‹æ‰‹æŒæ˜¯å¦å¼ å¼€
        function isPalmOpen(hand) {
            const fingers = [8, 12, 16, 20]; // æŒ‡å°–ç´¢å¼•
            const palmBase = hand[0];
            
            for (let finger of fingers) {
                if (hand[finger].y > hand[finger - 2].y) {
                    return false;
                }
            }
            return true;
        }
        
        // æ£€æµ‹é£ŸæŒ‡å’Œæ‹‡æŒ‡æ˜¯å¦æåˆ
        function isPinching(hand) {
            const thumb = hand[4];
            const index = hand[8];
            
            const distance = Math.sqrt(
                Math.pow(thumb.x - index.x, 2) + 
                Math.pow(thumb.y - index.y, 2)
            );
            
            return distance < 0.05;
        }
        
        // å¤„ç†å†™å­—
        function handleDrawing(hand) {
            if (isPinching(hand)) {
                const indexFinger = hand[8];
                const x = indexFinger.x * canvas.width;
                const y = indexFinger.y * canvas.height;
                
                if (!isDrawing) {
                    isDrawing = true;
                    lastPoint = { x, y };
                } else {
                    drawLine(lastPoint.x, lastPoint.y, x, y);
                    lastPoint = { x, y };
                }
            } else {
                isDrawing = false;
                lastPoint = null;
            }
        }
        
        // å¤„ç†åŒæ‰‹æ‰‹åŠ¿
        function handleTwoHands(hands) {
            const hand1 = hands[0];
            const hand2 = hands[1];
            
            // æ£€æµ‹ä¸¤åªæ‰‹çš„é£ŸæŒ‡
            const index1 = hand1[8];
            const index2 = hand2[8];
            
            const distance = Math.sqrt(
                Math.pow(index1.x - index2.x, 2) + 
                Math.pow(index1.y - index2.y, 2)
            );
            
            // ç¼©æ”¾åŠŸèƒ½
            if (distance > 0.2) {
                scale = Math.min(2, scale + 0.01);
            } else {
                scale = Math.max(0.5, scale - 0.01);
            }
            
            applyTransform();
            
            // æ£€æµ‹æ¶ˆæ•£æ‰‹åŠ¿ï¼ˆé£ŸæŒ‡å’Œä¸­æŒ‡åŒæ—¶å¼ å¼€ï¼‰
            if (isTwoFingersOpen(hand1) && isTwoFingersOpen(hand2)) {
                dissolveDrawing();
            }
        }
        
        // æ£€æµ‹é£ŸæŒ‡å’Œä¸­æŒ‡æ˜¯å¦å¼ å¼€
        function isTwoFingersOpen(hand) {
            const index = hand[8];
            const middle = hand[12];
            
            return index.y < hand[6].y && middle.y < hand[10].y;
        }
        
        // ç»˜åˆ¶çº¿æ¡
        function drawLine(x1, y1, x2, y2) {
            ctx.save();
            ctx.scale(-1, 1);
            ctx.translate(-canvas.width, 0);
            
            if (currentTool === 'pen') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = currentSize;
            } else {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.lineWidth = currentSize * 3;
            }
            
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            ctx.restore();
            
            // ä¿å­˜ç»˜åˆ¶æ•°æ®
            drawings.push({
                x1: x1, y1: y1, x2: x2, y2: y2,
                tool: currentTool, color: currentColor, size: currentSize
            });
        }
        
        // åº”ç”¨å˜æ¢
        function applyTransform() {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.scale(scale, scale);
            redrawAll();
            ctx.restore();
        }
        
        // é‡ç»˜æ‰€æœ‰å†…å®¹
        function redrawAll() {
            drawings.forEach(draw => {
                if (draw.tool === 'pen') {
                    ctx.globalCompositeOperation = 'source-over';
                    ctx.strokeStyle = draw.color;
                    ctx.lineWidth = draw.size;
                } else {
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.lineWidth = draw.size * 3;
                }
                
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                ctx.beginPath();
                ctx.moveTo(draw.x1, draw.y1);
                ctx.lineTo(draw.x2, draw.y2);
                ctx.stroke();
            });
        }
        
        // æ¶ˆæ•£æ•ˆæœ
        function dissolveDrawing() {
            const snowflakes = ['â„', 'â…', 'â†'];
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // åˆ›å»ºé›ªèŠ±æ•ˆæœ
            for (let i = 0; i < 50; i++) {
                setTimeout(() => {
                    const snowflake = document.createElement('div');
                    snowflake.className = 'snowflake';
                    snowflake.textContent = snowflakes[Math.floor(Math.random() * snowflakes.length)];
                    snowflake.style.left = Math.random() * window.innerWidth + 'px';
                    snowflake.style.top = -50 + 'px';
                    snowflake.style.animationDuration = (3 + Math.random() * 2) + 's';
                    
                    document.body.appendChild(snowflake);
                    
                    setTimeout(() => snowflake.remove(), 5000);
                }, i * 100);
            }
            
            // é€æ¸æ¶ˆå¤±ç”»å¸ƒå†…å®¹
            let opacity = 1;
            const fadeOut = setInterval(() => {
                opacity -= 0.02;
                ctx.globalAlpha = opacity;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                redrawAll();
                
                if (opacity <= 0) {
                    clearInterval(fadeOut);
                    ctx.globalAlpha = 1;
                    drawings = [];
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                }
            }, 50);
        }
        
        // æ›´æ–°å…‰æ ‡ä½ç½®
        function updateCursor(x, y) {
            cursorIndicator.style.left = x + 'px';
            cursorIndicator.style.top = y + 'px';
        }
        
        // å¤„ç†UIé€‰æ‹©
        function handleUISelection(x, y) {
            // è¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥æ£€æµ‹æ‰‹æŒ‡åœ¨UIå…ƒç´ ä¸Šçš„åœç•™æ—¶é—´
            const buttons = document.querySelectorAll('.tool-button');
            const colors = document.querySelectorAll('.color-option');
            
            // æ£€æµ‹å·¥å…·é€‰æ‹©
            buttons.forEach(button => {
                const rect = button.getBoundingClientRect();
                if (x >= rect.left && x <= rect.right && 
                    y >= rect.top && y <= rect.bottom) {
                    button.classList.add('selected');
                    currentTool = button.dataset.tool;
                } else {
                    button.classList.remove('selected');
                }
            });
            
            // æ£€æµ‹é¢œè‰²é€‰æ‹©
            colors.forEach(color => {
                const rect = color.getBoundingClientRect();
                if (x >= rect.left && x <= rect.right && 
                    y >= rect.top && y <= rect.bottom) {
                    color.classList.add('selected');
                    currentColor = color.dataset.color;
                } else {
                    color.classList.remove('selected');
                }
            });
        }
        
        // å¤§å°æ»‘å—äº‹ä»¶
        document.getElementById('size-slider').addEventListener('input', (e) => {
            currentSize = e.target.value;
            document.getElementById('size-display').textContent = currentSize + 'px';
        });
        
        // ä¸»å¾ªç¯
        async function main() {
            await initCamera();
            initMediaPipe();
            
            const camera = new Camera(video, {
                onFrame: async () => {
                    await hands.send({ image: video });
                },
                width: 1280,
                height: 720
            });
            
            camera.start();
        }
        
        // å¯åŠ¨åº”ç”¨
        main();
    </script>
</body>
</html>